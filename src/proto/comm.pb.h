// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/comm.proto

#ifndef PROTOBUF_proto_2fcomm_2eproto__INCLUDED
#define PROTOBUF_proto_2fcomm_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace trpc {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_proto_2fcomm_2eproto();
void protobuf_AssignDesc_proto_2fcomm_2eproto();
void protobuf_ShutdownFile_proto_2fcomm_2eproto();

class Stream;
class SessionHeader;
class Error;
class CallRequest;
class CallResponse;
class CallError;
class CallPayload;

enum Error_Type {
  Error_Type_UNKNOWN_ERROR = 0,
  Error_Type_PROTOCOL_ERROR = 1,
  Error_Type_UNKNOWN_MESSAGE = 2
};
bool Error_Type_IsValid(int value);
const Error_Type Error_Type_Type_MIN = Error_Type_UNKNOWN_ERROR;
const Error_Type Error_Type_Type_MAX = Error_Type_UNKNOWN_MESSAGE;
const int Error_Type_Type_ARRAYSIZE = Error_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Error_Type_descriptor();
inline const ::std::string& Error_Type_Name(Error_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Error_Type_descriptor(), value);
}
inline bool Error_Type_Parse(
    const ::std::string& name, Error_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Error_Type>(
    Error_Type_descriptor(), name, value);
}
enum CallError_Type {
  CallError_Type_UNKNOWN_ERROR = 0,
  CallError_Type_BAD_REQUEST = 1,
  CallError_Type_APPLICATION_ERROR = 2
};
bool CallError_Type_IsValid(int value);
const CallError_Type CallError_Type_Type_MIN = CallError_Type_UNKNOWN_ERROR;
const CallError_Type CallError_Type_Type_MAX = CallError_Type_APPLICATION_ERROR;
const int CallError_Type_Type_ARRAYSIZE = CallError_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* CallError_Type_descriptor();
inline const ::std::string& CallError_Type_Name(CallError_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    CallError_Type_descriptor(), value);
}
inline bool CallError_Type_Parse(
    const ::std::string& name, CallError_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CallError_Type>(
    CallError_Type_descriptor(), name, value);
}
// ===================================================================

class Stream : public ::google::protobuf::Message {
 public:
  Stream();
  virtual ~Stream();
  
  Stream(const Stream& from);
  
  inline Stream& operator=(const Stream& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Stream& default_instance();
  
  void Swap(Stream* other);
  
  // implements Message ----------------------------------------------
  
  Stream* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Stream& from);
  void MergeFrom(const Stream& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .trpc.proto.SessionHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::trpc::proto::SessionHeader& header() const;
  inline ::trpc::proto::SessionHeader* mutable_header();
  inline ::trpc::proto::SessionHeader* release_header();
  
  // repeated .trpc.proto.Error error = 2;
  inline int error_size() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::trpc::proto::Error& error(int index) const;
  inline ::trpc::proto::Error* mutable_error(int index);
  inline ::trpc::proto::Error* add_error();
  inline const ::google::protobuf::RepeatedPtrField< ::trpc::proto::Error >&
      error() const;
  inline ::google::protobuf::RepeatedPtrField< ::trpc::proto::Error >*
      mutable_error();
  
  // repeated .trpc.proto.CallRequest call_request = 3;
  inline int call_request_size() const;
  inline void clear_call_request();
  static const int kCallRequestFieldNumber = 3;
  inline const ::trpc::proto::CallRequest& call_request(int index) const;
  inline ::trpc::proto::CallRequest* mutable_call_request(int index);
  inline ::trpc::proto::CallRequest* add_call_request();
  inline const ::google::protobuf::RepeatedPtrField< ::trpc::proto::CallRequest >&
      call_request() const;
  inline ::google::protobuf::RepeatedPtrField< ::trpc::proto::CallRequest >*
      mutable_call_request();
  
  // repeated .trpc.proto.CallResponse call_response = 4;
  inline int call_response_size() const;
  inline void clear_call_response();
  static const int kCallResponseFieldNumber = 4;
  inline const ::trpc::proto::CallResponse& call_response(int index) const;
  inline ::trpc::proto::CallResponse* mutable_call_response(int index);
  inline ::trpc::proto::CallResponse* add_call_response();
  inline const ::google::protobuf::RepeatedPtrField< ::trpc::proto::CallResponse >&
      call_response() const;
  inline ::google::protobuf::RepeatedPtrField< ::trpc::proto::CallResponse >*
      mutable_call_response();
  
  // @@protoc_insertion_point(class_scope:trpc.proto.Stream)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::trpc::proto::SessionHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::trpc::proto::Error > error_;
  ::google::protobuf::RepeatedPtrField< ::trpc::proto::CallRequest > call_request_;
  ::google::protobuf::RepeatedPtrField< ::trpc::proto::CallResponse > call_response_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fcomm_2eproto();
  friend void protobuf_AssignDesc_proto_2fcomm_2eproto();
  friend void protobuf_ShutdownFile_proto_2fcomm_2eproto();
  
  void InitAsDefaultInstance();
  static Stream* default_instance_;
};
// -------------------------------------------------------------------

class SessionHeader : public ::google::protobuf::Message {
 public:
  SessionHeader();
  virtual ~SessionHeader();
  
  SessionHeader(const SessionHeader& from);
  
  inline SessionHeader& operator=(const SessionHeader& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SessionHeader& default_instance();
  
  void Swap(SessionHeader* other);
  
  // implements Message ----------------------------------------------
  
  SessionHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SessionHeader& from);
  void MergeFrom(const SessionHeader& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:trpc.proto.SessionHeader)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_proto_2fcomm_2eproto();
  friend void protobuf_AssignDesc_proto_2fcomm_2eproto();
  friend void protobuf_ShutdownFile_proto_2fcomm_2eproto();
  
  void InitAsDefaultInstance();
  static SessionHeader* default_instance_;
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message {
 public:
  Error();
  virtual ~Error();
  
  Error(const Error& from);
  
  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();
  
  void Swap(Error* other);
  
  // implements Message ----------------------------------------------
  
  Error* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Error_Type Type;
  static const Type UNKNOWN_ERROR = Error_Type_UNKNOWN_ERROR;
  static const Type PROTOCOL_ERROR = Error_Type_PROTOCOL_ERROR;
  static const Type UNKNOWN_MESSAGE = Error_Type_UNKNOWN_MESSAGE;
  static inline bool Type_IsValid(int value) {
    return Error_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Error_Type_Type_MIN;
  static const Type Type_MAX =
    Error_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Error_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Error_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Error_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Error_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .trpc.proto.Error.Type type = 1 [default = UNKNOWN_ERROR];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::trpc::proto::Error_Type type() const;
  inline void set_type(::trpc::proto::Error_Type value);
  
  // optional string description = 2;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 2;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  
  // @@protoc_insertion_point(class_scope:trpc.proto.Error)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_description();
  inline void clear_has_description();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* description_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fcomm_2eproto();
  friend void protobuf_AssignDesc_proto_2fcomm_2eproto();
  friend void protobuf_ShutdownFile_proto_2fcomm_2eproto();
  
  void InitAsDefaultInstance();
  static Error* default_instance_;
};
// -------------------------------------------------------------------

class CallRequest : public ::google::protobuf::Message {
 public:
  CallRequest();
  virtual ~CallRequest();
  
  CallRequest(const CallRequest& from);
  
  inline CallRequest& operator=(const CallRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CallRequest& default_instance();
  
  void Swap(CallRequest* other);
  
  // implements Message ----------------------------------------------
  
  CallRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CallRequest& from);
  void MergeFrom(const CallRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 call_id = 1;
  inline bool has_call_id() const;
  inline void clear_call_id();
  static const int kCallIdFieldNumber = 1;
  inline ::google::protobuf::int32 call_id() const;
  inline void set_call_id(::google::protobuf::int32 value);
  
  // optional int32 method_id = 2;
  inline bool has_method_id() const;
  inline void clear_method_id();
  static const int kMethodIdFieldNumber = 2;
  inline ::google::protobuf::int32 method_id() const;
  inline void set_method_id(::google::protobuf::int32 value);
  
  // optional .trpc.proto.CallPayload payload = 15;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 15;
  inline const ::trpc::proto::CallPayload& payload() const;
  inline ::trpc::proto::CallPayload* mutable_payload();
  inline ::trpc::proto::CallPayload* release_payload();
  
  // @@protoc_insertion_point(class_scope:trpc.proto.CallRequest)
 private:
  inline void set_has_call_id();
  inline void clear_has_call_id();
  inline void set_has_method_id();
  inline void clear_has_method_id();
  inline void set_has_payload();
  inline void clear_has_payload();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 call_id_;
  ::google::protobuf::int32 method_id_;
  ::trpc::proto::CallPayload* payload_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fcomm_2eproto();
  friend void protobuf_AssignDesc_proto_2fcomm_2eproto();
  friend void protobuf_ShutdownFile_proto_2fcomm_2eproto();
  
  void InitAsDefaultInstance();
  static CallRequest* default_instance_;
};
// -------------------------------------------------------------------

class CallResponse : public ::google::protobuf::Message {
 public:
  CallResponse();
  virtual ~CallResponse();
  
  CallResponse(const CallResponse& from);
  
  inline CallResponse& operator=(const CallResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CallResponse& default_instance();
  
  void Swap(CallResponse* other);
  
  // implements Message ----------------------------------------------
  
  CallResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CallResponse& from);
  void MergeFrom(const CallResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 call_id = 1;
  inline bool has_call_id() const;
  inline void clear_call_id();
  static const int kCallIdFieldNumber = 1;
  inline ::google::protobuf::int32 call_id() const;
  inline void set_call_id(::google::protobuf::int32 value);
  
  // optional .trpc.proto.CallError error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::trpc::proto::CallError& error() const;
  inline ::trpc::proto::CallError* mutable_error();
  inline ::trpc::proto::CallError* release_error();
  
  // optional .trpc.proto.CallPayload payload = 15;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 15;
  inline const ::trpc::proto::CallPayload& payload() const;
  inline ::trpc::proto::CallPayload* mutable_payload();
  inline ::trpc::proto::CallPayload* release_payload();
  
  // @@protoc_insertion_point(class_scope:trpc.proto.CallResponse)
 private:
  inline void set_has_call_id();
  inline void clear_has_call_id();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_payload();
  inline void clear_has_payload();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::trpc::proto::CallError* error_;
  ::trpc::proto::CallPayload* payload_;
  ::google::protobuf::int32 call_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fcomm_2eproto();
  friend void protobuf_AssignDesc_proto_2fcomm_2eproto();
  friend void protobuf_ShutdownFile_proto_2fcomm_2eproto();
  
  void InitAsDefaultInstance();
  static CallResponse* default_instance_;
};
// -------------------------------------------------------------------

class CallError : public ::google::protobuf::Message {
 public:
  CallError();
  virtual ~CallError();
  
  CallError(const CallError& from);
  
  inline CallError& operator=(const CallError& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CallError& default_instance();
  
  void Swap(CallError* other);
  
  // implements Message ----------------------------------------------
  
  CallError* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CallError& from);
  void MergeFrom(const CallError& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef CallError_Type Type;
  static const Type UNKNOWN_ERROR = CallError_Type_UNKNOWN_ERROR;
  static const Type BAD_REQUEST = CallError_Type_BAD_REQUEST;
  static const Type APPLICATION_ERROR = CallError_Type_APPLICATION_ERROR;
  static inline bool Type_IsValid(int value) {
    return CallError_Type_IsValid(value);
  }
  static const Type Type_MIN =
    CallError_Type_Type_MIN;
  static const Type Type_MAX =
    CallError_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    CallError_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return CallError_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return CallError_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return CallError_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .trpc.proto.CallError.Type type = 1 [default = UNKNOWN_ERROR];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::trpc::proto::CallError_Type type() const;
  inline void set_type(::trpc::proto::CallError_Type value);
  
  // optional string description = 2;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 2;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  
  // @@protoc_insertion_point(class_scope:trpc.proto.CallError)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_description();
  inline void clear_has_description();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* description_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fcomm_2eproto();
  friend void protobuf_AssignDesc_proto_2fcomm_2eproto();
  friend void protobuf_ShutdownFile_proto_2fcomm_2eproto();
  
  void InitAsDefaultInstance();
  static CallError* default_instance_;
};
// -------------------------------------------------------------------

class CallPayload : public ::google::protobuf::Message {
 public:
  CallPayload();
  virtual ~CallPayload();
  
  CallPayload(const CallPayload& from);
  
  inline CallPayload& operator=(const CallPayload& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CallPayload& default_instance();
  
  void Swap(CallPayload* other);
  
  // implements Message ----------------------------------------------
  
  CallPayload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CallPayload& from);
  void MergeFrom(const CallPayload& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes data = 15;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 15;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // @@protoc_insertion_point(class_scope:trpc.proto.CallPayload)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fcomm_2eproto();
  friend void protobuf_AssignDesc_proto_2fcomm_2eproto();
  friend void protobuf_ShutdownFile_proto_2fcomm_2eproto();
  
  void InitAsDefaultInstance();
  static CallPayload* default_instance_;
};
// ===================================================================


// ===================================================================

// Stream

// optional .trpc.proto.SessionHeader header = 1;
inline bool Stream::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Stream::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Stream::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Stream::clear_header() {
  if (header_ != NULL) header_->::trpc::proto::SessionHeader::Clear();
  clear_has_header();
}
inline const ::trpc::proto::SessionHeader& Stream::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::trpc::proto::SessionHeader* Stream::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::trpc::proto::SessionHeader;
  return header_;
}
inline ::trpc::proto::SessionHeader* Stream::release_header() {
  clear_has_header();
  ::trpc::proto::SessionHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// repeated .trpc.proto.Error error = 2;
inline int Stream::error_size() const {
  return error_.size();
}
inline void Stream::clear_error() {
  error_.Clear();
}
inline const ::trpc::proto::Error& Stream::error(int index) const {
  return error_.Get(index);
}
inline ::trpc::proto::Error* Stream::mutable_error(int index) {
  return error_.Mutable(index);
}
inline ::trpc::proto::Error* Stream::add_error() {
  return error_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::trpc::proto::Error >&
Stream::error() const {
  return error_;
}
inline ::google::protobuf::RepeatedPtrField< ::trpc::proto::Error >*
Stream::mutable_error() {
  return &error_;
}

// repeated .trpc.proto.CallRequest call_request = 3;
inline int Stream::call_request_size() const {
  return call_request_.size();
}
inline void Stream::clear_call_request() {
  call_request_.Clear();
}
inline const ::trpc::proto::CallRequest& Stream::call_request(int index) const {
  return call_request_.Get(index);
}
inline ::trpc::proto::CallRequest* Stream::mutable_call_request(int index) {
  return call_request_.Mutable(index);
}
inline ::trpc::proto::CallRequest* Stream::add_call_request() {
  return call_request_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::trpc::proto::CallRequest >&
Stream::call_request() const {
  return call_request_;
}
inline ::google::protobuf::RepeatedPtrField< ::trpc::proto::CallRequest >*
Stream::mutable_call_request() {
  return &call_request_;
}

// repeated .trpc.proto.CallResponse call_response = 4;
inline int Stream::call_response_size() const {
  return call_response_.size();
}
inline void Stream::clear_call_response() {
  call_response_.Clear();
}
inline const ::trpc::proto::CallResponse& Stream::call_response(int index) const {
  return call_response_.Get(index);
}
inline ::trpc::proto::CallResponse* Stream::mutable_call_response(int index) {
  return call_response_.Mutable(index);
}
inline ::trpc::proto::CallResponse* Stream::add_call_response() {
  return call_response_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::trpc::proto::CallResponse >&
Stream::call_response() const {
  return call_response_;
}
inline ::google::protobuf::RepeatedPtrField< ::trpc::proto::CallResponse >*
Stream::mutable_call_response() {
  return &call_response_;
}

// -------------------------------------------------------------------

// SessionHeader

// -------------------------------------------------------------------

// Error

// optional .trpc.proto.Error.Type type = 1 [default = UNKNOWN_ERROR];
inline bool Error::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Error::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Error::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Error::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::trpc::proto::Error_Type Error::type() const {
  return static_cast< ::trpc::proto::Error_Type >(type_);
}
inline void Error::set_type(::trpc::proto::Error_Type value) {
  GOOGLE_DCHECK(::trpc::proto::Error_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string description = 2;
inline bool Error::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Error::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Error::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Error::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& Error::description() const {
  return *description_;
}
inline void Error::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Error::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Error::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Error::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* Error::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CallRequest

// optional int32 call_id = 1;
inline bool CallRequest::has_call_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CallRequest::set_has_call_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CallRequest::clear_has_call_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CallRequest::clear_call_id() {
  call_id_ = 0;
  clear_has_call_id();
}
inline ::google::protobuf::int32 CallRequest::call_id() const {
  return call_id_;
}
inline void CallRequest::set_call_id(::google::protobuf::int32 value) {
  set_has_call_id();
  call_id_ = value;
}

// optional int32 method_id = 2;
inline bool CallRequest::has_method_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CallRequest::set_has_method_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CallRequest::clear_has_method_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CallRequest::clear_method_id() {
  method_id_ = 0;
  clear_has_method_id();
}
inline ::google::protobuf::int32 CallRequest::method_id() const {
  return method_id_;
}
inline void CallRequest::set_method_id(::google::protobuf::int32 value) {
  set_has_method_id();
  method_id_ = value;
}

// optional .trpc.proto.CallPayload payload = 15;
inline bool CallRequest::has_payload() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CallRequest::set_has_payload() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CallRequest::clear_has_payload() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CallRequest::clear_payload() {
  if (payload_ != NULL) payload_->::trpc::proto::CallPayload::Clear();
  clear_has_payload();
}
inline const ::trpc::proto::CallPayload& CallRequest::payload() const {
  return payload_ != NULL ? *payload_ : *default_instance_->payload_;
}
inline ::trpc::proto::CallPayload* CallRequest::mutable_payload() {
  set_has_payload();
  if (payload_ == NULL) payload_ = new ::trpc::proto::CallPayload;
  return payload_;
}
inline ::trpc::proto::CallPayload* CallRequest::release_payload() {
  clear_has_payload();
  ::trpc::proto::CallPayload* temp = payload_;
  payload_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// CallResponse

// optional int32 call_id = 1;
inline bool CallResponse::has_call_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CallResponse::set_has_call_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CallResponse::clear_has_call_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CallResponse::clear_call_id() {
  call_id_ = 0;
  clear_has_call_id();
}
inline ::google::protobuf::int32 CallResponse::call_id() const {
  return call_id_;
}
inline void CallResponse::set_call_id(::google::protobuf::int32 value) {
  set_has_call_id();
  call_id_ = value;
}

// optional .trpc.proto.CallError error = 2;
inline bool CallResponse::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CallResponse::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CallResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CallResponse::clear_error() {
  if (error_ != NULL) error_->::trpc::proto::CallError::Clear();
  clear_has_error();
}
inline const ::trpc::proto::CallError& CallResponse::error() const {
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::trpc::proto::CallError* CallResponse::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::trpc::proto::CallError;
  return error_;
}
inline ::trpc::proto::CallError* CallResponse::release_error() {
  clear_has_error();
  ::trpc::proto::CallError* temp = error_;
  error_ = NULL;
  return temp;
}

// optional .trpc.proto.CallPayload payload = 15;
inline bool CallResponse::has_payload() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CallResponse::set_has_payload() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CallResponse::clear_has_payload() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CallResponse::clear_payload() {
  if (payload_ != NULL) payload_->::trpc::proto::CallPayload::Clear();
  clear_has_payload();
}
inline const ::trpc::proto::CallPayload& CallResponse::payload() const {
  return payload_ != NULL ? *payload_ : *default_instance_->payload_;
}
inline ::trpc::proto::CallPayload* CallResponse::mutable_payload() {
  set_has_payload();
  if (payload_ == NULL) payload_ = new ::trpc::proto::CallPayload;
  return payload_;
}
inline ::trpc::proto::CallPayload* CallResponse::release_payload() {
  clear_has_payload();
  ::trpc::proto::CallPayload* temp = payload_;
  payload_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// CallError

// optional .trpc.proto.CallError.Type type = 1 [default = UNKNOWN_ERROR];
inline bool CallError::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CallError::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CallError::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CallError::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::trpc::proto::CallError_Type CallError::type() const {
  return static_cast< ::trpc::proto::CallError_Type >(type_);
}
inline void CallError::set_type(::trpc::proto::CallError_Type value) {
  GOOGLE_DCHECK(::trpc::proto::CallError_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string description = 2;
inline bool CallError::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CallError::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CallError::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CallError::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& CallError::description() const {
  return *description_;
}
inline void CallError::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void CallError::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void CallError::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CallError::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* CallError::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CallPayload

// optional bytes data = 15;
inline bool CallPayload::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CallPayload::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CallPayload::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CallPayload::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& CallPayload::data() const {
  return *data_;
}
inline void CallPayload::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void CallPayload::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void CallPayload::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CallPayload::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* CallPayload::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace trpc

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trpc::proto::Error_Type>() {
  return ::trpc::proto::Error_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trpc::proto::CallError_Type>() {
  return ::trpc::proto::CallError_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_2fcomm_2eproto__INCLUDED
